/*
 * CryptBuddingApp.cpp
 *
 * Standalone Chaste app for crypt budding / organoid simulations.
 * Equivalent to TestCryptBudding.hpp but as a proper executable with
 * CLI arguments instead of environment variables.
 *
 * Usage:
 *   ./CryptBuddingApp -model node2d -stiffness 5.0 -run 0
 *   ./CryptBuddingApp -model vertex3d -stiffness 2.0 -run 3 -lumen 0 -ecm 1
 *
 * Arguments:
 *   -model <node2d|vertex2d|node3d|vertex3d>   (required)
 *   -stiffness <double>                         ECM stiffness  (default: 5.0)
 *   -run <int>                                  run/replicate  (default: 0)
 *   -lumen <0|1>                                lumen pressure (default: 1)
 *   -apical <0|1>                               apical constriction (default: 1)
 *   -ecm <0|1>                                  ECM guidance 3D (default: 0)
 *   -relax <0|1>                                relaxation phase (default: 1)
 *   -slough <0|1>                               sloughing 2D (default: 1)
 *   -diffadh <0|1>                              differential adhesion (default: 1)
 *   -endtime <double>                           override end time
 *   -dt <double>                                override timestep
 *   -help                                       print usage
 */

#include <cmath>
#include <cstdlib>
#include <string>
#include <sstream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <iomanip>
#include <map>
#include <chrono>
#include <iostream>

// ===================================================================
// Core Chaste
// ===================================================================
#include "ExecutableSupport.hpp"
#include "Exception.hpp"
#include "PetscTools.hpp"
#include "PetscException.hpp"
#include "CheckpointArchiveTypes.hpp"
#include "SmartPointers.hpp"
#include "SimulationTime.hpp"
#include "RandomNumberGenerator.hpp"
#include "OutputFileHandler.hpp"

// ===================================================================
// Mesh & population — 2D node
// ===================================================================
#include "NodesOnlyMesh.hpp"
#include "NodeBasedCellPopulation.hpp"

// ===================================================================
// Mesh & population — 2D vertex
// ===================================================================
#include "MutableVertexMesh.hpp"
#include "VertexBasedCellPopulation.hpp"

// ===================================================================
// Mesh & population — 3D vertex (OrganoidChaste)
// ===================================================================
#include "MonolayerVertexBasedCellPopulation.hpp"
#include "MutableMonolayerVertexMesh.hpp"
#include "FiniteThicknessRandomizedSphereMeshGenerator.hpp"
#include "FiniteThicknessSimulation3d.hpp"

// ===================================================================
// Simulation
// ===================================================================
#include "OffLatticeSimulation.hpp"

// ===================================================================
// Forces
// ===================================================================
#include "NagaiHondaForce.hpp"
#include "SurfaceTensionForce.hpp"
#include "GeneralisedLinearSpringForce.hpp"

// ===================================================================
// Cell cycle
// ===================================================================
#include "ContactInhibitionCellCycleModel.hpp"
#include "NoCellCycleModel.hpp"

// ===================================================================
// Cell types & states
// ===================================================================
#include "TransitCellProliferativeType.hpp"
#include "StemCellProliferativeType.hpp"
#include "DifferentiatedCellProliferativeType.hpp"
#include "WildTypeCellMutationState.hpp"
#include "ApcOneHitCellMutationState.hpp"
#include "ApcTwoHitCellMutationState.hpp"

// ===================================================================
// Cell killers
// ===================================================================
#include "PlaneBasedCellKiller.hpp"

// ===================================================================
// Modifiers & writers
// ===================================================================
#include "VolumeTrackingModifier.hpp"
#include "SimpleTargetAreaModifier.hpp"
#include "GeometricalTargetVolumeModifier.hpp"
#include "CellIdWriter.hpp"
#include "CellAgesWriter.hpp"
#include "CellVolumesWriter.hpp"
#include "CellProliferativeTypesCountWriter.hpp"
#include "CellProliferativeTypesWriter.hpp"
#include "CellThicknessWriter.hpp"
#include "FaceTypeWriter.hpp"

// ===================================================================
// TissueMorphology project forces
// ===================================================================
#include "DifferentialAdhesionForce.hpp"
#include "BasementMembraneForce.hpp"
#include "LumenPressureForce.hpp"
#include "ApicalConstrictionForce.hpp"

// ===================================================================
// TissueMorphology & OrganoidChaste — 3D ECM
// ===================================================================
#include "DynamicECMContactGuidanceForce3d.hpp"
#include "DynamicECMField3d.hpp"
#include "ECMFieldWriter3d.hpp"
#include "LumenPressureSubForce.hpp"


// ===================================================================
// Parameters — identical to TestCryptBudding.hpp CryptBuddingParams
// ===================================================================

struct CryptBuddingParams
{
    std::string modelType;
    double ecmStiffness;
    unsigned runNumber;
    unsigned randomSeed;

    bool enableLumenPressure;
    bool enableApicalConstriction;
    bool enableEcmGuidance;
    bool enableRelaxation;
    bool enableSloughing;
    bool enableDifferentialAdhesion;

    double dt;
    double dtGrow;     // Phase 2 growth dt for vertex3d (separate from relaxation dt)
    double relaxationTime;
    double endTime;
    unsigned samplingMultiple;

    double organoidRadius2d;
    unsigned numCells2dNode;
    unsigned numCells2dVertex;
    double innerRadius2d;
    double outerRadius2d;
    double interactionCutoff2d;

    unsigned numCells3dNode;
    unsigned numCells3dVertex;
    double organoidRadius3d;
    double shellThickness3d;
    double interactionCutoff3d;
    double sphereRadius3dVertex;

    double bmStiffnessNode;
    double bmStiffnessVertex;
    double bmRadius2d;
    double bmRadius3d;
    double ecmDegradationRate;
    double ecmMaxRadius2d;
    double ecmMaxRadius3d;

    double lumenPressure;
    double lumenEqRadius2d;

    double apicalConstrictionStrength;

    double springStiffness;
    double springCutoff;
    double apicalApicalAdhesion;
    double basalBasalAdhesion;
    double apicalBasalAdhesion;

    double nhMembraneSurface;
    double nhCellCellAdhesion;
    double nhBoundaryAdhesion;

    double gammaApical;
    double gammaBasal;
    double gammaLateral;

    // Per-cell-type surface tension scaling (vertex models)
    // Stem cells are softer, Paneth/differentiated cells are stiffer
    double gammaStemScale;
    double gammaTransitScale;
    double gammaDiffScale;      // Paneth-like cells

    double quiescentFraction;
    double sloughRadiusFactor;

    double ecmDomainHalf;
    double ecmGridSpacing;
    double ecmBaseSpeed;

    double t1Threshold2d;
    double t2Threshold2d;

    // Cell type proportions for uniform random distribution
    double stemFraction;
    double transitFraction;
    // remainder (1 - stemFraction - transitFraction) = differentiated/Paneth

    // Whether endTime/dt were explicitly set by user
    bool endTimeOverridden;
    bool dtOverridden;

    void SetDefaults()
    {
        modelType = "";
        ecmStiffness = 5.0;
        runNumber = 0;
        enableLumenPressure = true;
        enableApicalConstriction = true;
        enableEcmGuidance = false;
        enableRelaxation = true;
        enableSloughing = true;
        enableDifferentialAdhesion = true;
        endTimeOverridden = false;
        dtOverridden = false;
        endTime = 168.0;
        dt = 0.005;
        dtGrow = 0.002;   // Phase 2 growth dt for vertex3d (reduced from 0.006 for stability)

        relaxationTime = 10.0;

        organoidRadius2d    = 8.0;
        numCells2dNode      = 80;
        numCells2dVertex    = 40;
        innerRadius2d       = 6.0;
        outerRadius2d       = 8.0;
        interactionCutoff2d = 2.5;

        numCells3dNode       = 100;
        numCells3dVertex     = 200;
        organoidRadius3d     = 25.0;
        shellThickness3d     = 3.0;
        interactionCutoff3d  = 15.0;
        sphereRadius3dVertex = 10.0;

        lumenPressure   = 2.0;
        lumenEqRadius2d = organoidRadius2d + 1.0;

        apicalConstrictionStrength = 3.0;

        springStiffness       = 30.0;
        springCutoff          = 1.5;
        apicalApicalAdhesion  = 1.2;
        basalBasalAdhesion    = 1.0;
        apicalBasalAdhesion   = 0.5;

        nhMembraneSurface  = 10.0;
        nhCellCellAdhesion = 1.0;
        nhBoundaryAdhesion = 2.0;

        gammaApical  = 0.85;
        gammaBasal   = 0.85;
        gammaLateral = 0.7;

        // Per-cell-type scaling: stem cells softer, Paneth cells stiffer
        gammaStemScale    = 0.7;   // stem cells are more compliant
        gammaTransitScale = 1.0;   // baseline
        gammaDiffScale    = 1.3;   // Paneth/differentiated are stiffer

        quiescentFraction  = 0.7;
        sloughRadiusFactor = 5.0;

        ecmDomainHalf  = 80.0;
        ecmGridSpacing = 10.0;
        ecmBaseSpeed   = 0.3;
    }

    void Finalise()
    {
        randomSeed = static_cast<unsigned>(ecmStiffness * 10000) + runNumber * 137;

        bmStiffnessNode   = ecmStiffness;
        bmStiffnessVertex = ecmStiffness * 0.5;
        bmRadius2d        = organoidRadius2d + 2.0;
        bmRadius3d        = 30.0;
        ecmDegradationRate = 0.02;
        ecmMaxRadius2d     = organoidRadius2d * 4.0;
        ecmMaxRadius3d     = 80.0;

        t1Threshold2d = (ecmStiffness < 2.0) ? 0.2 : 0.15;
        t2Threshold2d = 0.05;

        // Model-specific defaults for dt/endTime/sampling if not overridden
        if (modelType == "node2d")
        {
            if (!dtOverridden) dt = 0.005;
            samplingMultiple = 200;
        }
        else if (modelType == "vertex2d")
        {
            if (!dtOverridden)
                dt = (ecmStiffness < 1.0) ? 0.0002
                   : (ecmStiffness < 5.0) ? 0.0005
                   :                        0.0005;
            samplingMultiple = static_cast<unsigned>(1.0 / dt);
            if (!endTimeOverridden) endTime = 168.0;
        }
        else if (modelType == "node3d")
        {
            if (!dtOverridden) dt = 0.01;
            samplingMultiple = 20;
            if (!endTimeOverridden) endTime = 168.0;
        }
        else if (modelType == "vertex3d")
        {
            if (!dtOverridden) dt = 0.001;
            samplingMultiple = 20;
            if (!endTimeOverridden) endTime = 100.0;
        }

        // Cell type proportions for uniform distribution
        stemFraction = 0.2;
        transitFraction = 0.5;
        // remainder = differentiated/Paneth
        else
        {
            samplingMultiple = 200;
        }
    }
};


// ===================================================================
// Summary modifier — writes radial statistics to CSV + progress
// ===================================================================

template<unsigned DIM>
class CryptBuddingSummaryModifier : public AbstractCellBasedSimulationModifier<DIM>
{
private:
    std::string mOutputDir;
    double mStiffness;
    double mEndTime;
    bool mHeaderWritten;
    unsigned mSamplingMultiple;
    unsigned mLogInterval;
    unsigned mLastOutputStep;
    unsigned mLastLogStep;
    double mReferenceVolume;      // expected average cell volume
    unsigned mInstabilityCount;   // consecutive instability warnings

public:
    CryptBuddingSummaryModifier(double stiffness, unsigned samplingMultiple,
                                double endTime = 200.0, double referenceVolume = 1.0)
        : AbstractCellBasedSimulationModifier<DIM>(),
          mStiffness(stiffness),
          mEndTime(endTime),
          mHeaderWritten(false),
          mSamplingMultiple(samplingMultiple),
          mLogInterval(samplingMultiple / 6),
          mLastOutputStep(0),
          mLastLogStep(0),
          mReferenceVolume(referenceVolume),
          mInstabilityCount(0)
    {
        if (mLogInterval == 0) mLogInterval = 1;
    }

    void SetupSolve(AbstractCellPopulation<DIM,DIM>& rCellPopulation,
                    std::string outputDirectory)
    {
        mOutputDir = outputDirectory;
    }

    void UpdateAtEndOfTimeStep(AbstractCellPopulation<DIM,DIM>& rCellPopulation)
    {
        unsigned current_step = SimulationTime::Instance()->GetTimeStepsElapsed();
        double current_time  = SimulationTime::Instance()->GetTime();
        unsigned num_cells   = rCellPopulation.GetNumRealCells();

        // Progress log — stdout is real-time in app mode (no CTest buffering)
        if (current_step == 0 || current_step - mLastLogStep >= mLogInterval)
        {
            mLastLogStep = current_step;
            double pct = (mEndTime > 0.0) ? (current_time / mEndTime) * 100.0 : 0.0;
            std::cout << "[Progress] t=" << std::fixed << std::setprecision(1)
                      << current_time << "h / " << mEndTime << "h  ("
                      << std::setprecision(1) << pct << "%)  cells="
                      << num_cells << std::endl;
        }

        // ---- Numerical stability monitoring ----
        // Check max cell volume against reference volume
        double max_vol = 0.0;
        double min_vol = 1e30;
        unsigned bad_cell_id = 0;
        for (typename AbstractCellPopulation<DIM>::Iterator it = rCellPopulation.Begin();
             it != rCellPopulation.End(); ++it)
        {
            double vol = it->GetCellData()->GetItem("volume");
            if (vol > max_vol) {
                max_vol = vol;
                bad_cell_id = it->GetCellData()->GetItem("Cell IDs");
            }
            if (vol < min_vol) min_vol = vol;
        }

        double vol_ratio = (mReferenceVolume > 0.0) ? max_vol / mReferenceVolume : 0.0;

        if (vol_ratio > 10.0)
        {
            mInstabilityCount++;
            std::cerr << "[INSTABILITY WARNING] t=" << std::fixed << std::setprecision(3)
                      << current_time << "  step=" << current_step
                      << "  max_volume=" << std::setprecision(2) << max_vol
                      << " (" << vol_ratio << "x reference)"
                      << "  cell_id=" << bad_cell_id
                      << "  min_volume=" << std::setprecision(4) << min_vol
                      << "  (consecutive warnings: " << mInstabilityCount << ")"
                      << std::endl;

            if (vol_ratio > 1000.0)
            {
                std::cerr << "[FATAL INSTABILITY] Volume ratio " << vol_ratio
                          << "x exceeds catastrophic threshold (1000x reference)."
                          << " Simulation is numerically diverging. Consider reducing dt."
                          << std::endl;
                EXCEPTION("Numerical instability detected: cell volume "
                          + std::to_string(max_vol)
                          + " exceeds 1000x reference volume "
                          + std::to_string(mReferenceVolume)
                          + " at t=" + std::to_string(current_time));
            }
        }
        else
        {
            mInstabilityCount = 0;  // reset if volumes return to normal
        }

        // CSV at sampling interval
        if (current_step - mLastOutputStep < mSamplingMultiple && current_step > 0)
            return;
        mLastOutputStep = current_step;

        // Compute centroid
        c_vector<double, DIM> centroid = zero_vector<double>(DIM);
        for (typename AbstractCellPopulation<DIM>::Iterator it = rCellPopulation.Begin();
             it != rCellPopulation.End(); ++it)
        {
            centroid += rCellPopulation.GetLocationOfCellCentre(*it);
        }
        if (num_cells > 0) centroid /= static_cast<double>(num_cells);

        double sum_r = 0.0, sum_r2 = 0.0;
        double max_r = -1e10, min_r = 1e10;

        for (typename AbstractCellPopulation<DIM>::Iterator it = rCellPopulation.Begin();
             it != rCellPopulation.End(); ++it)
        {
            c_vector<double, DIM> pos = rCellPopulation.GetLocationOfCellCentre(*it);
            double r = norm_2(pos - centroid);
            sum_r  += r;
            sum_r2 += r * r;
            if (r > max_r) max_r = r;
            if (r < min_r) min_r = r;
        }

        double mean_r = (num_cells > 0) ? sum_r / num_cells : 0.0;
        double var_r  = (num_cells > 1) ? (sum_r2 / num_cells - mean_r * mean_r) : 0.0;

        // Write CSV
        std::string filename = OutputFileHandler::GetChasteTestOutputDirectory()
                               + mOutputDir + "/crypt_summary.csv";
        std::ofstream file;
        if (!mHeaderWritten)
        {
            file.open(filename.c_str());
            file << "time,num_cells,mean_r,var_r,max_r,min_r,r_range,max_vol,min_vol,stiffness" << std::endl;
            mHeaderWritten = true;
        }
        else
        {
            file.open(filename.c_str(), std::ios::app);
        }

        file << std::fixed << std::setprecision(4)
             << current_time << "," << num_cells << ","
             << mean_r << "," << var_r << ","
             << max_r << "," << min_r << ","
             << (max_r - min_r) << ","
             << max_vol << "," << min_vol << ","
             << mStiffness
             << std::endl;
        file.close();
    }

    void OutputSimulationModifierParameters(out_stream& rParamsFile)
    {
        *rParamsFile << "\t\t<Stiffness>" << mStiffness << "</Stiffness>\n";
        AbstractCellBasedSimulationModifier<DIM>::OutputSimulationModifierParameters(rParamsFile);
    }
};


// ===================================================================
// Utilities
// ===================================================================

inline void AssignCellTypeByFraction(
    CellPtr pCell, double /*frac*/,
    boost::shared_ptr<AbstractCellProliferativeType> pStemType,
    boost::shared_ptr<AbstractCellProliferativeType> pTransitType,
    boost::shared_ptr<AbstractCellProliferativeType> pDiffType,
    double stemFraction = 0.2, double transitFraction = 0.5)
{
    // Uniformly random cell type assignment: each cell independently draws
    // from the target proportions, giving a spatially uniform distribution
    // across the organoid surface (rather than z-band segregation).
    double u = RandomNumberGenerator::Instance()->ranf();
    if (u < stemFraction)
    {
        pCell->SetCellProliferativeType(pStemType);
        pCell->GetCellData()->SetItem("cell_type_id", 0.0);
    }
    else if (u < stemFraction + transitFraction)
    {
        pCell->SetCellProliferativeType(pTransitType);
        pCell->GetCellData()->SetItem("cell_type_id", 1.0);
    }
    else
    {
        pCell->SetCellProliferativeType(pDiffType);
        pCell->GetCellData()->SetItem("cell_type_id", 2.0);
    }
}

inline double AngularFraction2d(double x, double y,
                                double cx = 0.0, double cy = 0.0)
{
    double theta = atan2(y - cy, x - cx);
    double angle_from_bottom = theta + M_PI / 2.0;
    if (angle_from_bottom < 0.0) angle_from_bottom += 2.0 * M_PI;
    return angle_from_bottom / (2.0 * M_PI);
}

inline double ZFractionToRingFraction(double z, double R)
{
    double z_frac = z / R;
    if (z_frac < -0.5)      return 0.0;
    else if (z_frac < 0.3)  return 0.3;
    else                     return 0.5;
}

template<unsigned DIM>
void AddBoundingBoxKillers(OffLatticeSimulation<DIM>& rSimulator,
                           AbstractCellPopulation<DIM>& rPopulation,
                           double halfWidth)
{
    for (unsigned d = 0; d < DIM; d++)
    {
        {
            c_vector<double, DIM> point  = zero_vector<double>(DIM);
            c_vector<double, DIM> normal = zero_vector<double>(DIM);
            point[d]  =  halfWidth;
            normal[d] =  1.0;
            MAKE_PTR_ARGS(PlaneBasedCellKiller<DIM>, p_killer,
                          (&rPopulation, point, normal));
            rSimulator.AddCellKiller(p_killer);
        }
        {
            c_vector<double, DIM> point  = zero_vector<double>(DIM);
            c_vector<double, DIM> normal = zero_vector<double>(DIM);
            point[d]  = -halfWidth;
            normal[d] = -1.0;
            MAKE_PTR_ARGS(PlaneBasedCellKiller<DIM>, p_killer,
                          (&rPopulation, point, normal));
            rSimulator.AddCellKiller(p_killer);
        }
    }
}

void PrintBanner(const CryptBuddingParams& p)
{
    std::cout << "\n============================================" << std::endl;
    std::cout << "  Crypt Budding Simulation" << std::endl;
    std::cout << "  Model:          " << p.modelType << std::endl;
    std::cout << "  ECM Stiffness:  " << p.ecmStiffness << std::endl;
    std::cout << "  Run Number:     " << p.runNumber << std::endl;
    std::cout << "  Seed:           " << p.randomSeed << std::endl;
    std::cout << "  dt:             " << p.dt << std::endl;
    if (p.modelType == "vertex3d")
        std::cout << "  dt (growth):    " << p.dtGrow << std::endl;
    std::cout << "  Relaxation:     " << (p.enableRelaxation ? "ON" : "OFF")
              << " (" << p.relaxationTime << "h)" << std::endl;
    std::cout << "  End Time:       " << p.endTime << "h" << std::endl;
    std::cout << "  Cell fractions: stem=" << p.stemFraction
              << " TA=" << p.transitFraction
              << " diff=" << (1.0 - p.stemFraction - p.transitFraction) << std::endl;
    if (p.modelType == "vertex3d")
    {
        std::cout << "  Gamma scaling:  stem=" << p.gammaStemScale
                  << " TA=" << p.gammaTransitScale
                  << " diff/Paneth=" << p.gammaDiffScale << std::endl;
    }
    std::cout << "  Features:" << std::endl;
    std::cout << "    Lumen Pressure:        " << (p.enableLumenPressure ? "ON" : "OFF") << std::endl;
    std::cout << "    Apical Constriction:    " << (p.enableApicalConstriction ? "ON" : "OFF") << std::endl;
    std::cout << "    ECM Guidance (3D):      " << (p.enableEcmGuidance ? "ON" : "OFF") << std::endl;
    std::cout << "    Sloughing:              " << (p.enableSloughing ? "ON" : "OFF") << std::endl;
    std::cout << "    Differential Adhesion:  " << (p.enableDifferentialAdhesion ? "ON" : "OFF") << std::endl;
    std::cout << "============================================\n" << std::endl;
}

void PrintUsage()
{
    std::cout << "Usage: CryptBuddingApp -model <type> [options]\n"
              << "\nRequired:\n"
              << "  -model <node2d|vertex2d|node3d|vertex3d>\n"
              << "\nOptions:\n"
              << "  -stiffness <double>   ECM stiffness (default: 5.0)\n"
              << "  -run <int>            run/replicate number (default: 0)\n"
              << "  -lumen <0|1>          lumen pressure (default: 1)\n"
              << "  -apical <0|1>         apical constriction (default: 1)\n"
              << "  -ecm <0|1>            ECM guidance, 3D only (default: 0)\n"
              << "  -relax <0|1>          relaxation phase (default: 1)\n"
              << "  -slough <0|1>         sloughing, 2D only (default: 1)\n"
              << "  -diffadh <0|1>        differential adhesion (default: 1)\n"
              << "  -endtime <double>     override end time\n"
              << "  -dt <double>          override timestep (relaxation in vertex3d)\n"
              << "  -dtgrow <double>      growth phase timestep, vertex3d (default: 0.002)\n"
              << "  -help                 print this message\n"
              << std::endl;
}

CryptBuddingParams ParseArguments(int argc, char* argv[])
{
    CryptBuddingParams p;
    p.SetDefaults();

    for (int i = 1; i < argc; i++)
    {
        std::string arg = argv[i];

        if (arg == "-help" || arg == "--help")
        {
            PrintUsage();
            exit(0);
        }
        else if (arg == "-model" && i + 1 < argc)
        {
            p.modelType = argv[++i];
        }
        else if (arg == "-stiffness" && i + 1 < argc)
        {
            p.ecmStiffness = std::stod(argv[++i]);
        }
        else if (arg == "-run" && i + 1 < argc)
        {
            p.runNumber = static_cast<unsigned>(std::stoi(argv[++i]));
        }
        else if (arg == "-lumen" && i + 1 < argc)
        {
            p.enableLumenPressure = (std::stoi(argv[++i]) != 0);
        }
        else if (arg == "-apical" && i + 1 < argc)
        {
            p.enableApicalConstriction = (std::stoi(argv[++i]) != 0);
        }
        else if (arg == "-ecm" && i + 1 < argc)
        {
            p.enableEcmGuidance = (std::stoi(argv[++i]) != 0);
        }
        else if (arg == "-relax" && i + 1 < argc)
        {
            p.enableRelaxation = (std::stoi(argv[++i]) != 0);
        }
        else if (arg == "-slough" && i + 1 < argc)
        {
            p.enableSloughing = (std::stoi(argv[++i]) != 0);
        }
        else if (arg == "-diffadh" && i + 1 < argc)
        {
            p.enableDifferentialAdhesion = (std::stoi(argv[++i]) != 0);
        }
        else if (arg == "-endtime" && i + 1 < argc)
        {
            p.endTime = std::stod(argv[++i]);
            p.endTimeOverridden = true;
        }
        else if (arg == "-dt" && i + 1 < argc)
        {
            p.dt = std::stod(argv[++i]);
            p.dtOverridden = true;
        }
        else if (arg == "-dtgrow" && i + 1 < argc)
        {
            p.dtGrow = std::stod(argv[++i]);
        }
        else
        {
            std::cerr << "WARNING: Unknown argument '" << arg << "'" << std::endl;
        }
    }

    return p;
}


// ===================================================================
// Build annular vertex mesh for 2D vertex model
// ===================================================================

boost::shared_ptr<MutableVertexMesh<2,2>> MakeAnnularVertexMesh(
    unsigned numElements, double innerR, double outerR,
    double t1, double t2)
{
    std::vector<Node<2>*> vNodes;
    double dtheta = 2.0 * M_PI / static_cast<double>(numElements);

    for (unsigned i = 0; i < numElements; i++)
    {
        double theta = i * dtheta;
        vNodes.push_back(new Node<2>(i, true,
                                     innerR * cos(theta), innerR * sin(theta)));
    }
    for (unsigned i = 0; i < numElements; i++)
    {
        double theta = i * dtheta;
        vNodes.push_back(new Node<2>(numElements + i, true,
                                     outerR * cos(theta), outerR * sin(theta)));
    }

    std::vector<VertexElement<2,2>*> elements;
    for (unsigned i = 0; i < numElements; i++)
    {
        unsigned ni = (i + 1) % numElements;
        std::vector<Node<2>*> en;
        en.push_back(vNodes[i]);
        en.push_back(vNodes[numElements + i]);
        en.push_back(vNodes[numElements + ni]);
        en.push_back(vNodes[ni]);
        elements.push_back(new VertexElement<2,2>(i, en));
    }

    boost::shared_ptr<MutableVertexMesh<2,2>> pMesh(
        new MutableVertexMesh<2,2>(vNodes, elements, t1, t2));
    pMesh->SetCellRearrangementRatio(1.5);
    pMesh->SetProtorosetteFormationProbability(0.0);
    pMesh->SetProtorosetteResolutionProbabilityPerTimestep(1.0);
    pMesh->SetCheckForInternalIntersections(true);
    return pMesh;
}


// ===================================================================
// MODEL 1: 2D Node-Based
// ===================================================================

void RunNode2d(const CryptBuddingParams& p, const std::string& outputDir)
{
    RandomNumberGenerator::Instance()->Reseed(p.randomSeed);

    std::vector<Node<2>*> nodes;
    for (unsigned i = 0; i < p.numCells2dNode; i++)
    {
        double theta = 2.0 * M_PI * i / p.numCells2dNode;
        double r_noise = p.organoidRadius2d +
            (RandomNumberGenerator::Instance()->ranf() - 0.5) * 0.3;
        double x = r_noise * cos(theta);
        double y = r_noise * sin(theta);
        nodes.push_back(new Node<2>(i, false, x, y));
    }

    NodesOnlyMesh<2> mesh;
    mesh.ConstructNodesWithoutMesh(nodes, p.interactionCutoff2d);
    for (unsigned i = 0; i < nodes.size(); i++) delete nodes[i];

    std::vector<CellPtr> cells;
    MAKE_PTR(WildTypeCellMutationState, p_state);
    MAKE_PTR(StemCellProliferativeType, p_stem);
    MAKE_PTR(TransitCellProliferativeType, p_ta);
    MAKE_PTR(DifferentiatedCellProliferativeType, p_diff);
    RandomNumberGenerator* p_gen = RandomNumberGenerator::Instance();

    for (unsigned i = 0; i < mesh.GetNumNodes(); i++)
    {
        ContactInhibitionCellCycleModel* p_cycle = new ContactInhibitionCellCycleModel();
        p_cycle->SetDimension(2);
        p_cycle->SetQuiescentVolumeFraction(p.quiescentFraction);
        p_cycle->SetEquilibriumVolume(1.0);

        CellPtr p_cell(new Cell(p_state, p_cycle));
        AssignCellTypeByFraction(p_cell, 0.0, p_stem, p_ta, p_diff,
                                 p.stemFraction, p.transitFraction);

        p_cell->SetBirthTime(-p_gen->ranf() * 12.0);
        p_cell->InitialiseCellCycleModel();
        p_cell->GetCellData()->SetItem("volume", 1.0);
        p_cell->GetCellData()->SetItem("basement_membrane_stiffness", p.bmStiffnessNode);
        p_cell->GetCellData()->SetItem("is_apical", 1.0);
        cells.push_back(p_cell);
    }

    NodeBasedCellPopulation<2> population(mesh, cells);
    population.SetAbsoluteMovementThreshold(50.0);
    population.AddCellWriter<CellIdWriter>();
    population.AddCellWriter<CellAgesWriter>();
    population.AddCellWriter<CellVolumesWriter>();
    population.AddCellPopulationCountWriter<CellProliferativeTypesCountWriter>();

    OffLatticeSimulation<2> simulator(population);
    simulator.SetOutputDirectory(outputDir);
    simulator.SetDt(p.dt);
    simulator.SetSamplingTimestepMultiple(p.samplingMultiple);
    simulator.SetEndTime(p.endTime);

    if (p.enableDifferentialAdhesion)
    {
        MAKE_PTR(DifferentialAdhesionForce<2>, p_spring);
        p_spring->SetMeinekeSpringStiffness(p.springStiffness);
        p_spring->SetCutOffLength(p.springCutoff);
        p_spring->SetMeinekeDivisionRestingSpringLength(0.5);
        p_spring->SetMeinekeSpringGrowthDuration(1.0);
        p_spring->SetApicalApicalAdhesion(p.apicalApicalAdhesion);
        p_spring->SetBasalBasalAdhesion(p.basalBasalAdhesion);
        p_spring->SetApicalBasalAdhesion(p.apicalBasalAdhesion);
        simulator.AddForce(p_spring);
    }
    else
    {
        MAKE_PTR(GeneralisedLinearSpringForce<2>, p_spring);
        p_spring->SetMeinekeSpringStiffness(p.springStiffness);
        p_spring->SetCutOffLength(p.springCutoff);
        simulator.AddForce(p_spring);
    }

    MAKE_PTR(BasementMembraneForce<2>, p_bm);
    p_bm->SetBasementMembraneParameter(p.bmStiffnessNode);
    p_bm->SetBasementMembraneRadius(p.bmRadius2d);
    c_vector<double, 2> center2d = zero_vector<double>(2);
    p_bm->SetOrganoidCenter(center2d);
    p_bm->EnableEcmDegradation(p.ecmDegradationRate, p.ecmMaxRadius2d);
    simulator.AddForce(p_bm);

    if (p.enableLumenPressure)
    {
        MAKE_PTR(LumenPressureForce<2>, p_lumen);
        p_lumen->SetPressureStrength(p.lumenPressure);
        p_lumen->SetLumenEquilibriumRadius(p.lumenEqRadius2d);
        p_lumen->SetTrackCenter(true);
        simulator.AddForce(p_lumen);
    }

    if (p.enableApicalConstriction)
    {
        MAKE_PTR(ApicalConstrictionForce<2>, p_ac);
        p_ac->SetConstrictionStrength(p.apicalConstrictionStrength);
        simulator.AddForce(p_ac);
    }

    if (p.enableSloughing)
    {
        AddBoundingBoxKillers<2>(simulator, population,
                                p.organoidRadius2d * p.sloughRadiusFactor);
    }

    MAKE_PTR(VolumeTrackingModifier<2>, p_vol);
    simulator.AddSimulationModifier(p_vol);

    boost::shared_ptr<CryptBuddingSummaryModifier<2>> p_summary(
        new CryptBuddingSummaryModifier<2>(p.ecmStiffness, p.samplingMultiple,
                                           p.relaxationTime + p.endTime));
    simulator.AddSimulationModifier(p_summary);

    if (p.enableRelaxation)
    {
        std::map<CellPtr, boost::shared_ptr<AbstractCellProperty>> origTypes;
        for (AbstractCellPopulation<2>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            origTypes[*it] = it->GetCellProliferativeType();
            it->SetCellProliferativeType(p_diff);
        }

        simulator.SetEndTime(p.relaxationTime);
        std::cout << "--- Phase 1: Relaxation (" << p.relaxationTime << "h) ---" << std::endl;
        simulator.Solve();

        for (AbstractCellPopulation<2>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            if (origTypes.count(*it)) it->SetCellProliferativeType(origTypes[*it]);
        }

        simulator.SetEndTime(p.relaxationTime + p.endTime);
        std::cout << "--- Phase 2: Growth (" << p.endTime << "h) ---" << std::endl;
        simulator.Solve();
    }
    else
    {
        simulator.Solve();
    }

    unsigned final_cells = population.GetNumRealCells();
    std::cout << "\nSIMULATION COMPLETE  |  Final cells: " << final_cells << std::endl;
    if (final_cells == 0)
        EXCEPTION("Simulation ended with zero cells");
}


// ===================================================================
// MODEL 2: 2D Vertex-Based
// ===================================================================

void RunVertex2d(const CryptBuddingParams& p, const std::string& outputDir)
{
    RandomNumberGenerator::Instance()->Reseed(p.randomSeed);

    boost::shared_ptr<MutableVertexMesh<2,2>> pMesh =
        MakeAnnularVertexMesh(p.numCells2dVertex, p.innerRadius2d, p.outerRadius2d,
                              p.t1Threshold2d, p.t2Threshold2d);

    for (unsigned i = 0; i < pMesh->GetNumNodes(); i++)
    {
        c_vector<double, 2> pos = pMesh->GetNode(i)->rGetLocation();
        double r = norm_2(pos);
        if (r > 1e-6)
        {
            double noise = (RandomNumberGenerator::Instance()->ranf() - 0.5) * 0.2;
            pos += noise * (pos / r);
            ChastePoint<2> pt(pos[0], pos[1]);
            pMesh->GetNode(i)->SetPoint(pt);
        }
    }

    double dtheta = 2.0 * M_PI / static_cast<double>(p.numCells2dVertex);
    double target_area = 0.5 * dtheta
        * (p.outerRadius2d * p.outerRadius2d - p.innerRadius2d * p.innerRadius2d);

    std::vector<CellPtr> cells;
    MAKE_PTR(WildTypeCellMutationState, p_state);
    MAKE_PTR(StemCellProliferativeType, p_stem);
    MAKE_PTR(TransitCellProliferativeType, p_ta);
    MAKE_PTR(DifferentiatedCellProliferativeType, p_diff);
    RandomNumberGenerator* p_gen = RandomNumberGenerator::Instance();

    for (unsigned i = 0; i < pMesh->GetNumElements(); i++)
    {
        ContactInhibitionCellCycleModel* p_cycle = new ContactInhibitionCellCycleModel();
        p_cycle->SetDimension(2);
        p_cycle->SetQuiescentVolumeFraction(p.quiescentFraction);
        p_cycle->SetEquilibriumVolume(target_area);

        CellPtr p_cell(new Cell(p_state, p_cycle));
        AssignCellTypeByFraction(p_cell, 0.0, p_stem, p_ta, p_diff,
                                 p.stemFraction, p.transitFraction);

        p_cell->SetBirthTime(-p_gen->ranf() * 12.0);
        p_cell->InitialiseCellCycleModel();
        p_cell->GetCellData()->SetItem("target area", target_area);
        p_cell->GetCellData()->SetItem("volume", target_area);
        p_cell->GetCellData()->SetItem("basement_membrane_stiffness", p.bmStiffnessVertex);
        p_cell->GetCellData()->SetItem("is_apical", 1.0);
        cells.push_back(p_cell);
    }

    VertexBasedCellPopulation<2> population(*pMesh, cells);
    population.AddCellWriter<CellIdWriter>();
    population.AddCellWriter<CellAgesWriter>();
    population.AddCellWriter<CellVolumesWriter>();
    population.AddCellPopulationCountWriter<CellProliferativeTypesCountWriter>();

    OffLatticeSimulation<2> simulator(population);
    simulator.SetOutputDirectory(outputDir);
    simulator.SetDt(p.dt);
    simulator.SetSamplingTimestepMultiple(p.samplingMultiple);
    simulator.SetEndTime(p.endTime);

    MAKE_PTR(NagaiHondaForce<2>, p_nh);
    p_nh->SetNagaiHondaDeformationEnergyParameter(p.ecmStiffness);
    p_nh->SetNagaiHondaMembraneSurfaceEnergyParameter(p.nhMembraneSurface);
    p_nh->SetNagaiHondaCellCellAdhesionEnergyParameter(p.nhCellCellAdhesion);
    p_nh->SetNagaiHondaCellBoundaryAdhesionEnergyParameter(p.nhBoundaryAdhesion);
    simulator.AddForce(p_nh);

    MAKE_PTR(BasementMembraneForce<2>, p_bm);
    p_bm->SetBasementMembraneParameter(p.bmStiffnessVertex);
    p_bm->SetBasementMembraneRadius(p.outerRadius2d + 2.0);
    c_vector<double, 2> center2d = zero_vector<double>(2);
    p_bm->SetOrganoidCenter(center2d);
    p_bm->EnableEcmDegradation(p.ecmDegradationRate, p.outerRadius2d * 4.0);
    simulator.AddForce(p_bm);

    if (p.enableLumenPressure)
    {
        MAKE_PTR(LumenPressureForce<2>, p_lumen);
        p_lumen->SetPressureStrength(p.lumenPressure);
        p_lumen->SetLumenEquilibriumRadius(p.outerRadius2d + 1.0);
        p_lumen->SetTrackCenter(true);
        simulator.AddForce(p_lumen);
    }

    if (p.enableApicalConstriction)
    {
        MAKE_PTR(ApicalConstrictionForce<2>, p_ac);
        p_ac->SetConstrictionStrength(p.apicalConstrictionStrength);
        simulator.AddForce(p_ac);
    }

    if (p.enableSloughing)
    {
        AddBoundingBoxKillers<2>(simulator, population,
                                p.outerRadius2d * p.sloughRadiusFactor);
    }

    MAKE_PTR(SimpleTargetAreaModifier<2>, p_area);
    p_area->SetReferenceTargetArea(target_area);
    simulator.AddSimulationModifier(p_area);

    MAKE_PTR(VolumeTrackingModifier<2>, p_vol);
    simulator.AddSimulationModifier(p_vol);

    boost::shared_ptr<CryptBuddingSummaryModifier<2>> p_summary(
        new CryptBuddingSummaryModifier<2>(p.ecmStiffness, p.samplingMultiple, p.endTime));
    simulator.AddSimulationModifier(p_summary);

    if (p.enableRelaxation)
    {
        std::map<CellPtr, boost::shared_ptr<AbstractCellProperty>> origTypes;
        for (AbstractCellPopulation<2>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            origTypes[*it] = it->GetCellProliferativeType();
            it->SetCellProliferativeType(p_diff);
        }

        simulator.SetEndTime(p.relaxationTime);
        std::cout << "--- Phase 1: Relaxation (" << p.relaxationTime << "h) ---" << std::endl;
        simulator.Solve();

        for (AbstractCellPopulation<2>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            if (origTypes.count(*it)) it->SetCellProliferativeType(origTypes[*it]);
        }

        simulator.SetEndTime(p.relaxationTime + p.endTime);
        std::cout << "--- Phase 2: Growth (" << p.endTime << "h) ---" << std::endl;
        simulator.Solve();
    }
    else
    {
        simulator.Solve();
    }

    unsigned final_cells = population.GetNumRealCells();
    std::cout << "\nSIMULATION COMPLETE  |  Final cells: " << final_cells << std::endl;
    if (final_cells == 0)
        EXCEPTION("Simulation ended with zero cells");
}


// ===================================================================
// MODEL 3: 3D Node-Based
// ===================================================================

void RunNode3d(const CryptBuddingParams& p, const std::string& outputDir)
{
    RandomNumberGenerator::Instance()->Reseed(p.randomSeed);

    std::vector<Node<3>*> nodes;
    RandomNumberGenerator* p_gen = RandomNumberGenerator::Instance();
    double golden = (1.0 + sqrt(5.0)) / 2.0;

    for (unsigned i = 0; i < p.numCells3dNode; i++)
    {
        double theta = 2.0 * M_PI * i / golden;
        double phi = acos(1.0 - 2.0 * (i + 0.5) / p.numCells3dNode);
        double r = p.organoidRadius3d + (p_gen->ranf() - 0.5) * p.shellThickness3d;
        double x = r * sin(phi) * cos(theta);
        double y = r * sin(phi) * sin(theta);
        double z = r * cos(phi);
        nodes.push_back(new Node<3>(i, false, x, y, z));
    }

    NodesOnlyMesh<3> mesh;
    mesh.ConstructNodesWithoutMesh(nodes, p.interactionCutoff3d);
    for (unsigned i = 0; i < nodes.size(); i++) delete nodes[i];

    std::vector<CellPtr> cells;
    MAKE_PTR(WildTypeCellMutationState, p_state);
    MAKE_PTR(StemCellProliferativeType, p_stem);
    MAKE_PTR(TransitCellProliferativeType, p_ta);
    MAKE_PTR(DifferentiatedCellProliferativeType, p_diff);

    for (unsigned i = 0; i < mesh.GetNumNodes(); i++)
    {
        ContactInhibitionCellCycleModel* p_cycle = new ContactInhibitionCellCycleModel();
        p_cycle->SetDimension(3);
        p_cycle->SetQuiescentVolumeFraction(p.quiescentFraction);
        p_cycle->SetEquilibriumVolume(1.0);

        CellPtr p_cell(new Cell(p_state, p_cycle));
        AssignCellTypeByFraction(p_cell, 0.0, p_stem, p_ta, p_diff,
                                 p.stemFraction, p.transitFraction);

        p_cell->SetBirthTime(-p_gen->ranf() * 18.0);
        p_cell->InitialiseCellCycleModel();
        p_cell->GetCellData()->SetItem("volume", 1.0);
        p_cell->GetCellData()->SetItem("basement_membrane_stiffness", p.bmStiffnessNode);
        p_cell->GetCellData()->SetItem("is_apical", 1.0);
        cells.push_back(p_cell);
    }

    NodeBasedCellPopulation<3> population(mesh, cells);
    population.SetAbsoluteMovementThreshold(50.0);
    population.AddCellWriter<CellIdWriter>();
    population.AddCellWriter<CellAgesWriter>();
    population.AddCellPopulationCountWriter<CellProliferativeTypesCountWriter>();

    OffLatticeSimulation<3> simulator(population);
    simulator.SetOutputDirectory(outputDir);
    simulator.SetDt(p.dt);
    simulator.SetSamplingTimestepMultiple(p.samplingMultiple);
    simulator.SetEndTime(p.endTime);

    if (p.enableDifferentialAdhesion)
    {
        MAKE_PTR(DifferentialAdhesionForce<3>, p_spring);
        p_spring->SetMeinekeSpringStiffness(p.springStiffness);
        p_spring->SetCutOffLength(p.interactionCutoff3d);
        p_spring->SetMeinekeDivisionRestingSpringLength(0.5);
        p_spring->SetMeinekeSpringGrowthDuration(1.0);
        p_spring->SetApicalApicalAdhesion(p.apicalApicalAdhesion);
        p_spring->SetBasalBasalAdhesion(p.basalBasalAdhesion);
        p_spring->SetApicalBasalAdhesion(p.apicalBasalAdhesion);
        simulator.AddForce(p_spring);
    }
    else
    {
        MAKE_PTR(GeneralisedLinearSpringForce<3>, p_spring);
        p_spring->SetMeinekeSpringStiffness(p.springStiffness);
        p_spring->SetCutOffLength(p.interactionCutoff3d);
        simulator.AddForce(p_spring);
    }

    MAKE_PTR(BasementMembraneForce<3>, p_bm);
    p_bm->SetBasementMembraneParameter(p.bmStiffnessNode);
    p_bm->SetTargetRadius(p.bmRadius3d);
    p_bm->EnableEcmDegradation(p.ecmDegradationRate, p.ecmMaxRadius3d);
    simulator.AddForce(p_bm);

    if (p.enableLumenPressure)
    {
        MAKE_PTR(LumenPressureForce<3>, p_lumen);
        p_lumen->SetPressureStrength(p.lumenPressure);
        p_lumen->SetLumenEquilibriumRadius(p.organoidRadius3d + 1.0);
        p_lumen->SetTrackCenter(true);
        simulator.AddForce(p_lumen);
    }

    if (p.enableApicalConstriction)
    {
        MAKE_PTR(ApicalConstrictionForce<3>, p_ac);
        p_ac->SetConstrictionStrength(p.apicalConstrictionStrength);
        simulator.AddForce(p_ac);
    }

    boost::shared_ptr<DynamicECMField3d> pEcmField;
    if (p.enableEcmGuidance)
    {
        pEcmField.reset(new DynamicECMField3d(
            "radial", p.ecmGridSpacing,
            -p.ecmDomainHalf, p.ecmDomainHalf,
            -p.ecmDomainHalf, p.ecmDomainHalf,
            -p.ecmDomainHalf, p.ecmDomainHalf));
        pEcmField->SetDegradationRate(0.002);
        pEcmField->SetRemodelingRate(0.05);
        pEcmField->SetDepositionRate(0.0003);

        MAKE_PTR(DynamicECMContactGuidanceForce3d, p_ecm);
        p_ecm->SetECMField(pEcmField);
        p_ecm->SetBaseSpeed(p.ecmBaseSpeed);
        p_ecm->SetECMSensitivity(1.0);
        p_ecm->SetEnableDegradation(true);
        p_ecm->SetEnableRemodeling(true);
        p_ecm->SetEnableDeposition(false);
        simulator.AddForce(p_ecm);
    }

    if (p.enableSloughing)
    {
        AddBoundingBoxKillers<3>(simulator, population,
                                p.organoidRadius3d * p.sloughRadiusFactor);
    }

    MAKE_PTR(VolumeTrackingModifier<3>, p_vol);
    simulator.AddSimulationModifier(p_vol);

    boost::shared_ptr<CryptBuddingSummaryModifier<3>> p_summary(
        new CryptBuddingSummaryModifier<3>(p.ecmStiffness, p.samplingMultiple,
                                           p.relaxationTime + p.endTime));
    simulator.AddSimulationModifier(p_summary);

    if (p.enableRelaxation), avgVol
    {
        std::map<CellPtr, boost::shared_ptr<AbstractCellProperty>> origTypes;
        for (AbstractCellPopulation<3>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            origTypes[*it] = it->GetCellProliferativeType();
            it->SetCellProliferativeType(p_diff);
        }

        simulator.SetEndTime(p.relaxationTime);
        std::cout << "--- Phase 1: Relaxation (" << p.relaxationTime << "h) ---" << std::endl;
        simulator.Solve();

        for (AbstractCellPopulation<3>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            if (origTypes.count(*it)) it->SetCellProliferativeType(origTypes[*it]);
        }

        simulator.SetEndTime(p.relaxationTime + p.endTime);
        std::cout << "--- Phase 2: Growth (" << p.endTime << "h) ---" << std::endl;
        simulator.Solve();
    }
    else
    {
        simulator.Solve();
    }

    unsigned final_cells = population.GetNumRealCells();
    std::cout << "\nSIMULATION COMPLETE  |  Final cells: " << final_cells << std::endl;
    if (final_cells == 0)
        EXCEPTION("Simulation ended with zero cells");
}


// ===================================================================
// MODEL 4: 3D Vertex-Based (OrganoidChaste)
// ===================================================================

void RunVertex3d(const CryptBuddingParams& p, const std::string& outputDir)
{
    RandomNumberGenerator::Instance()->Reseed(p.randomSeed);

    double height = 2.0 / 3.0 / sqrt(3.0)
                    * cbrt((9.0 / 2.0) * (9.0 / 2.0))
                    * cbrt((p.gammaApical + p.gammaBasal) / p.gammaLateral
                           * (p.gammaApical + p.gammaBasal) / p.gammaLateral)
                    * 1.0;
    double t1_length = 0.66 / cbrt(3.0 * 3.0
                       * (1.0 + p.gammaLateral) / p.gammaLateral);

    std::cout << "  Cell height:    " << height << std::endl;
    std::cout << "  T1 threshold:   " << t1_length << std::endl;

    FiniteThicknessRandomizedSphereMeshGenerator generator(
        p.numCells3dVertex, t1_length, 0.001, height, p.sphereRadius3dVertex);
    MutableMonolayerVertexMesh<3, 3>* pMesh = generator.GetMesh();
    pMesh->SetProtorosetteFormationProbability(1.0);
    pMesh->SetProtorosetteResolutionProbabilityPerTimestep(0.1);

    if (pMesh->GetNumElements() != p.numCells3dVertex)
        std::cerr << "WARNING: mesh has " << pMesh->GetNumElements()
                  << " elements, expected " << p.numCells3dVertex << std::endl;

    double outerR = p.sphereRadius3dVertex + height;
    double avgVol = 4.0 / 3.0 * M_PI
                    * (outerR * outerR * outerR
                       - p.sphereRadius3dVertex * p.sphereRadius3dVertex * p.sphereRadius3dVertex)
                    / p.numCells3dVertex;
// Use different mutation states to encode cell type for SurfaceTensionForce:
    //   WildType   = stem cells     (softer, gamma × gammaStemScale)
    //   ApcOneHit  = transit-amplifying (baseline, gamma × gammaTransitScale)
    //   ApcTwoHit  = differentiated/Paneth (stiffer, gamma × gammaDiffScale)
    MAKE_PTR(WildTypeCellMutationState, p_stem_mut);
    MAKE_PTR(ApcOneHitCellMutationState, p_ta_mut);
    MAKE_PTR(ApcTwoHitCellMutationState, p_diff_mut);
    MAKE_PTR(StemCellProliferativeType, p_stem);
    MAKE_PTR(TransitCellProliferativeType, p_ta);
    MAKE_PTR(DifferentiatedCellProliferativeType, p_diff);

    for (unsigned i = 0; i < p.numCells3dVertex; i++)
    {
        ContactInhibitionCellCycleModel* p_cycle = new ContactInhibitionCellCycleModel();
        p_cycle->SetDimension(3);
        p_cycle->SetQuiescentVolumeFraction(p.quiescentFraction);
        p_cycle->SetEquilibriumVolume(avgVol);

        // Uniform random cell type assignment across the organoid surface
        double u = RandomNumberGenerator::Instance()->ranf();
        boost::shared_ptr<AbstractCellMutationState> p_mut;
        boost::shared_ptr<AbstractCellProliferativeType> p_type;
        double type_id;

        if (u < p.stemFraction)
        {
            p_mut = p_stem_mut;
            p_type = p_stem;
            type_id = 0.0;
        }
        else if (u < p.stemFraction + p.transitFraction)
        {
            p_mut = p_ta_mut;
            p_type = p_ta;
            type_id = 1.0;
        }
        else
        {
            p_mut = p_diff_mut;
            p_type = p_diff;
            type_id = 2.0;
        }

        CellPtr p_cell(new Cell(p_mut, p_cycle));
        p_cell->SetCellProliferativeType(p_type);
        p_cell->GetCellData()->SetItem("cell_type_id", type_id);

        p_cell->SetBirthTime(-RandomNumberGenerator::Instance()->ranf() * 10.0);
        p_cell->InitialiseCellCycleModel();
        p_cell->GetCellData()->SetItem("volume", avgVol);
        p_cell->GetCellData()->SetItem("is_apical", 1.0);
        cells.push_back(p_cell);
    }

    MonolayerVertexBasedCellPopulation<3> population(*pMesh, cells);
    population.SetOutputCellRearrangementLocations(false);
    population.SetRestrictVertexMovementBoolean(false);
    population.SetDoInitialVolumeRelaxation(true);

    population.AddCellWriter<CellVolumesWriter>();
    population.AddCellWriter<CellThicknessWriter>();
    population.AddCellWriter<CellProliferativeTypesWriter>();
    population.AddCellWriter<CellAgesWriter>();
    population.AddFaceWriter<FaceTypeWriter>();

    FiniteThicknessSimulation3d simulator(population);
    simulator.SetOutputDirectory(outputDir);
    simulator.SetDt(p.dt);
    simulator.SetSamplingTimestepMultiple(p.samplingMultiple);

    // Create surface tension force with per-cell-type tensions via mutation state
    MAKE_PTR(SurfaceTensionForce<3>, p_tension);
    {
        std::map<boost::shared_ptr<AbstractCellMutationState>, std::array<double, 3>> mut_tension_map;
        mut_tension_map[p_stem_mut] = {{p.gammaApical * p.gammaStemScale,
                                        p.gammaBasal  * p.gammaStemScale,
                                        p.gammaLateral * p.gammaStemScale}};
        mut_tension_map[p_ta_mut]   = {{p.gammaApical * p.gammaTransitScale,
                                        p.gammaBasal  * p.gammaTransitScale,
                                        p.gammaLateral * p.gammaTransitScale}};
        mut_tension_map[p_diff_mut] = {{p.gammaApical * p.gammaDiffScale,
                                        p.gammaBasal  * p.gammaDiffScale,
                                        p.gammaLateral * p.gammaDiffScale}};
        p_tension->SetSurfaceTensionParametersByMutation(mut_tension_map);
        p_tension->UpdateSurfaceTensionsByMutation(&population);

        std::cout << "  Surface tensions (apical, basal, lateral):" << std::endl;
        std::cout << "    Stem:    " << p.gammaApical * p.gammaStemScale << ", "
                  << p.gammaBasal * p.gammaStemScale << ", "
                  << p.gammaLateral * p.gammaStemScale << std::endl;
        std::cout << "    Transit: " << p.gammaApical * p.gammaTransitScale << ", "
                  << p.gammaBasal * p.gammaTransitScale << ", "
                  << p.gammaLateral * p.gammaTransitScale << std::endl;
        std::cout << "    Paneth:  " << p.gammaApical * p.gammaDiffScale << ", "
                  << p.gammaBasal * p.gammaDiffScale << ", "
                  << p.gammaLateral * p.gammaDiffScale << std::endl;
    }
    p_tension->SetSimulatedAnnealingParameters(0.0, 50.0, 0.0);
    p_tension->SetSimulationInstance(&simulator);
    simulator.AddForce(p_tension);

    // NOTE: LumenPressureSubForce is added in Phase 2 only.
    // Adding it during relaxation destabilises the mesh → DIVERGED_ITS.

    MAKE_PTR(BasementMembraneForce<3>, p_bm);
    p_bm->SetBasementMembraneParameter(p.bmStiffnessVertex);
    p_bm->SetTargetRadius(p.sphereRadius3dVertex + height + 1.0);
    simulator.AddForce(p_bm);

    boost::shared_ptr<DynamicECMField3d> pEcmField;
    if (p.enableEcmGuidance)
    {
        pEcmField.reset(new DynamicECMField3d(
            "radial", p.ecmGridSpacing,
            -p.ecmDomainHalf, p.ecmDomainHalf,
            -p.ecmDomainHalf, p.ecmDomainHalf,
            -p.ecmDomainHalf, p.ecmDomainHalf));
        pEcmField->SetDegp.dtGrow;  // default 0.002, reduced from 0.006 for numerical stability
        unsigned sampling_grow = static_cast<unsigned>(std::max(1.0, 1.0 / dt_grow / 10.0))(0.05);
        pEcmField->SetDepositionRate(0.0003);
    }

    MAKE_PTR(VolumeTrackingModifier<3>, p_vol);
    simulator.AddSimulationModifier(p_vol);

    MAKE_PTR_ARGS(GeometricalTargetVolumeModifier<3>, p_gvol, (&population));
    p_gvol->SetGrowthDuration(0.0);
    p_gvol->SetT1AdaptationDuration(0.100);
    p_gvol->SetReferenceTargetVolume(avgVol);
    simulator.AddSimulationModifier(p_gvol);

    // Note: no sloughing killers for vertex3d because
    // MutableMonolayerVertexMesh does not support DeleteElementPriorToReMesh in 3D.

    if (p.enableRelaxation)
    {
        std::map<CellPtr, boost::shared_ptr<AbstractCellProperty>> origTypes;
        for (AbstractCellPopulation<3>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            origTypes[*it] = it->GetCellProliferativeType();
            it->SetCellProliferativeType(p_diff);
        }

        simulator.SetEndTime(p.relaxationTime);
        std::cout << "--- Phase 1: Relaxation (" << p.relaxationTime << " time-units) ---" << std::endl;
        simulator.Solve();
        std::cout << "Relaxation complete. Cells: " << population.GetNumRealCells() << std::endl;

        for (AbstractCellPopulation<3>::Iterator it = population.Begin();
             it != population.End(); ++it)
        {
            if (origTypes.count(*it)) it->SetCellProliferativeType(origTypes[*it]);
        }

        double dt_grow = 0.006;
        unsigned sampling_grow = 100;

        simulator.SetEndTime(p.relaxationTime + p.endTime);
        simulator.SetSamplingTimestepMultiple(sampling_grow);
        simulator.SetDt(dt_grow);

        p_tension->SetSimulatedAnnealingParameters(0.003, 1900000.0, 1.0);
        p_tension->SetSimulationInstance(&simulator);
        p_tension->SetPerformActiveT1Swaps(true);
        p_tension->SetT1TransitionParameters(2.0, false);

        p_bm->EnableEcmDegradation(p.ecmDegradationRate, p.ecmMaxRadius3d);

        // Add lumen pressure in Phase 2 (not during relaxation)
        if (p.enableLumenPressure)
        {
            MAKE_PTR_ARGS(LumenPressureSubForce<3>, p_lumen_sub, (p.lumenPressure));
            simulator.AddForce(p_lumen_sub);
        }

        if (p.enableEcmGuidance && pEcmField)
        {
            MAKE_PTR(DynamicECMContactGuidanceForce3d, p_ecm);
            p_ecm->SetECMField(pEcmField);
            p_ecm->SetBaseSpeed(p.ecmBaseSpeed);
            p_ecm->SetECMSensitivity(1.0);
            p_ecm->SetEnableDegradation(true);
            p_ecm->SetEnableRemodeling(true);
            p_ecm->SetEnableDeposition(false);
            simulator.AddForce(p_ecm);
        }

        std::cout << "--- Phase 2: Growth (" << p.endTime << " time-units) ---" << std::endl;
        simulator.Solve();
    }
    else
    {
        simulator.SetEndTime(p.endTime);
        simulator.Solve();
    }

    unsigned final_cells = population.GetNumRealCells();
    std::cout << "\nSIMULATION COMPLETE  |  Final cells: " << final_cells << std::endl;
    if (final_cells == 0)
        EXCEPTION("Simulation ended with zero cells");
}


// ===================================================================
// MAIN
// ===================================================================

int main(int argc, char* argv[])
{
    ExecutableSupport::StandardStartup(&argc, &argv);

    int exit_code = ExecutableSupport::EXIT_OK;

    try
    {
        if (argc < 2)
        {
            PrintUsage();
            ExecutableSupport::PrintError("No arguments provided. Use -model <type>.", true);
            exit_code = ExecutableSupport::EXIT_BAD_ARGUMENTS;
        }
        else
        {
            SimulationTime::Instance()->SetStartTime(0.0);

            CryptBuddingParams params = ParseArguments(argc, argv);

            if (params.modelType.empty())
            {
                PrintUsage();
                EXCEPTION("Required argument -model not provided");
            }

            params.Finalise();
            PrintBanner(params);

            // Build output directory
            std::stringstream subdir;
            subdir << "CryptBudding/" << params.modelType
                   << "/stiffness_" << std::fixed << std::setprecision(1) << params.ecmStiffness
                   << "/run_" << params.runNumber;

            if (params.modelType == "node2d")
            {
                RunNode2d(params, subdir.str());
            }
            else if (params.modelType == "vertex2d")
            {
                RunVertex2d(params, subdir.str());
            }
            else if (params.modelType == "node3d")
            {
                RunNode3d(params, subdir.str());
            }
            else if (params.modelType == "vertex3d")
            {
                RunVertex3d(params, subdir.str());
            }
            else
            {
                EXCEPTION("Unknown -model: " + params.modelType
                          + ". Options: node2d, vertex2d, node3d, vertex3d");
            }
        }
    }
    catch (const Exception& e)
    {
        ExecutableSupport::PrintError(e.GetMessage());
        exit_code = ExecutableSupport::EXIT_ERROR;
    }

    ExecutableSupport::WriteMachineInfoFile("machine_info");
    ExecutableSupport::FinalizePetsc();
    return exit_code;
}
